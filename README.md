# JavaDesign
## 策略模式 
### 概念
策略模式属于行为型模式，其主要目的是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而是得他们可以互相替换。<br/>
策略模式使得算法可以在不影响客户端的情况下发生变化。
### 重要角色
策略模式设计到三个重要角色：
1. 环境角色（Context）：只有一个Strategy的引用
2. 抽象策略角色（Strategy）：一个抽象角色，通常由一个接口或者抽象类实现，此角色给出所有的具体策略类所需的接口
3. 具体策略角色（ConcreteStrategy）：包装了相关的算法和行为 

### UML图
![image](https://raw.githubusercontent.com/petterheng/JavaDesign/master/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png)

### 代码存放位置
```java
package cn.sh.strategy;
```
**代码的逻辑是模仿会员购买东西打折**

### 理解策略模式
##### 策略模式重心
&emsp;策略模式的重心是如何**组织**和**调用**算法，从而让程序结构更灵活，具有更好的维护性和扩展性，并不是如何实现算法。
##### 算法的平等性
&emsp;对于一系列的策略算法，大家的地位是完全一样的，正是因为平等性的存在，才能实现算法之间的相互替换。**所有的策略算法在实现上是相互独立的，相互之间是没有依赖的**
##### 运行时策略的唯一性
&emsp;运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以**动态的在不同策略实现中切换，但是同时只能使用一个**。
##### 公有的行为
&emsp;当具体的策略类都有一些公有的行为时，应当把这些行为放到共同的抽象类角色Strategy类里面，当然这时候抽象策略角色必须使用**抽象类**实现，而不能使用**接口**。

### 策略模式优点
1. 策略模式提供了管理相关的算法族的办法。策略累的等级结构定义了一个算法或行为族，**恰当使用继承可以把公共的代码移到父类中，从而避免重复**。
2. 使用策略模式可以避免使用多重条件（if-else）语句，使得代码更加容易维护。

### 策略模式缺点
1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，**策略模式只适用用于客户端知道算法或行为的情况**
2. 策略模式需要把每个具体的策略实现都单独封装成类，如果备选策略很多，**对象数目则会比较多**


## 观察者模式
### 概念
定义了对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖者都会收到通知并自动更新。<br/>
观察者模式又称发布（Publish/Subscribe）订阅模式，模型视图（Model/View）模式，源-监听器模式（Source/Listener）模式或者从属者（Dependents）模式。<br/>
**出版者（主题）+ 订阅者（观察者）= 观察者模式**

### 重要角色
**抽象主题(Subject)角色**：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如Vector对象）里，每个主题都可以有任何数量的观察者。**抽象主题角色又叫做抽象被观察者(Observable)角色**。

**具体主题(ConcreteSubject)角色**：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。**具体主题角色又叫做具体被观察者(Concrete Observable)角色**。

**抽象观察者(Observer)角色**：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。

**具体观察者(ConcreteObserver)角色**：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。**如果需要，具体观察者角色可以保持一个指向具体主题对象的引用**。

### UML图
**此处的UML图与重要角色的描述有所出入，主要是因为在此处抽象主题角色采用的接口，而不是抽象类，**
![观察者模式.png](https://raw.githubusercontent.com/petterheng/JavaDesign/master/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png)

### 推模型和拉模型
在观察者模式中，又细分为**推模型**和**拉模型**<br/>
##### 推模型
&emsp;主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。
##### 拉模型
&emsp;主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。

### JDK对观察者模式的支持
1. java.util.Observable：可观察者（主题）<br/>
&emsp;该类有两个非常重要的方法，一个是**setChanged()**，另一个是**notifyObservers()**。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。
2. java.util.Observer：观察者<br/>
&emsp;update()方法,该方法有两个参数，第一个参数是**主题引用**，第二个参数是**主题调用notifyObservers()方法时传递的参数**。

### 代码地址
[观察者模式代码](https://github.com/petterheng/JavaDesign.git)
```java
package cn.sh.observer //自己实现的观察者模式
package cn.sh.jdk.observer //利用JDK提供的有关观察者模式的API
```

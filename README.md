# JavaDesign
### 概念
策略模式属于行为型模式，其主要目的是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而是得他们可以互相替换。<br/>
策略模式使得算法可以在不影响客户端的情况下发生变化。
### 重要角色
策略模式设计到三个重要角色：
1. 环境角色（Context）：只有一个Strategy的引用
2. 抽象策略角色（Strategy）：一个抽象角色，通常由一个接口或者抽象类实现，此角色给出所有的具体策略类所需的接口
3. 具体策略角色（ConcreteStrategy）：包装了相关的算法和行为 

### UML图
![image](https://raw.githubusercontent.com/petterheng/JavaDesign/master/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png)

### 代码存放位置
```java
package cn.sh.strategy;
```
**代码的逻辑是模仿会员购买东西打折**

### 理解策略模式
##### 策略模式重心
&emsp;策略模式的重心是如何**组织**和**调用**算法，从而让程序结构更灵活，具有更好的维护性和扩展性，并不是如何实现算法。
##### 算法的平等性
&emsp;对于一系列的策略算法，大家的地位是完全一样的，正是因为平等性的存在，才能实现算法之间的相互替换。**所有的策略算法在实现上是相互独立的，相互之间是没有依赖的**
##### 运行时策略的唯一性
&emsp;运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以**动态的在不同策略实现中切换，但是同时只能使用一个**。
##### 公有的行为
&emsp;当具体的策略类都有一些公有的行为时，应当把这些行为放到共同的抽象类角色Strategy类里面，当然这时候抽象策略角色必须使用**抽象类**实现，而不能使用**接口**。

### 策略模式优点
1. 策略模式提供了管理相关的算法族的办法。策略累的等级结构定义了一个算法或行为族，**恰当使用继承可以把公共的代码移到父类中，从而避免重复**。
2. 使用策略模式可以避免使用多重条件（if-else）语句，使得代码更加容易维护。

### 策略模式缺点
1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，**策略模式只适用用于客户端知道算法或行为的情况**
2. 策略模式需要把每个具体的策略实现都单独封装成类，如果备选策略很多，**对象数目则会比较多**
